"""AI service for generating card blueprints using Google Gemini."""

from datetime import datetime
from typing import Optional

from google import genai
from google.genai import types
from pydantic import BaseModel, Field, field_validator

from config import settings
from database.enums import AttackType, BiomeType, Rarity, StatusEffect
from logging_config import get_logger

logger = get_logger(__name__)


class Attack(BaseModel):
    """Pydantic model for card attack."""

    name: str = Field(..., description="Attack name in Ukrainian")
    type: AttackType = Field(..., description="Attack type enum")
    damage: int = Field(..., ge=0, le=100, description="Damage (0-100)")
    energy_cost: int = Field(..., ge=1, le=3, description="Energy cost (1-3)")
    effect: str | None = Field(
        default=None, description="Optional effect description"
    )
    status_effect: StatusEffect = Field(
        default=StatusEffect.NONE, description="Status effect enum"
    )


class Weakness(BaseModel):
    """Pydantic model for card weakness."""

    type: AttackType = Field(..., description="Attack type the card is weak to")
    multiplier: float = Field(..., ge=1.0, description="Damage multiplier (typically 2.0)")


class Resistance(BaseModel):
    """Pydantic model for card resistance."""

    type: AttackType = Field(..., description="Attack type the card resists")
    reduction: int = Field(..., ge=0, le=100, description="Damage reduction (typically 10-30)")


class CardBlueprint(BaseModel):
    """Pydantic model for card blueprint generated by AI."""

    target_user_id: int = Field(..., description="Target user ID for the card")
    card_name_ua: str = Field(..., description="Creative card name in Ukrainian, based on context (messages, personality, photos, descriptions). Should be thematic and memorable, not required to incorporate user's name.")
    rarity: Rarity = Field(..., description="Card rarity level")
    biome: BiomeType = Field(..., description="Card biome type")
    stats_atk: int = Field(..., ge=0, le=100, description="Attack stat (0-100)")
    stats_def: int = Field(..., ge=0, le=100, description="Defense stat (0-100)")
    stats_meme: int = Field(..., ge=0, le=100, description="Meme stat (0-100)")
    lore_ua: str = Field(
        ..., max_length=500, description="Card lore in Ukrainian (2 sentences max)"
    )
    raw_image_prompt_en: str = Field(
        ..., description="Descriptive prompt for visual elements only (English)"
    )
    dominant_color_hex: str = Field(
        ..., description="Primary color for gradients and accents (hex format, e.g., #FF5733)"
    )
    accent_color_hex: str = Field(
        ..., description="Secondary color for highlights and details (hex format, e.g., #33FF57)"
    )
    attacks: list[Attack] = Field(
        default_factory=list,
        description="List of Attack objects. Each attack has: name (Ukrainian), type (AttackType enum), damage (0-100), energy_cost (1-3), effect (optional string), status_effect (StatusEffect enum, default NONE). Cards should have 1-2 attacks based on rarity (Common: 1, Rare+: 2)."
    )
    weakness: Weakness | None = Field(
        default=None,
        description="Weakness object with type (AttackType enum) and multiplier (float, typically 2.0). Cards should have a weakness to one attack type that makes thematic sense (e.g., Fire weak to Water)."
    )
    resistance: Resistance | None = Field(
        default=None,
        description="Resistance object with type (AttackType enum) and reduction (int, typically 10-30). Cards may have resistance to one attack type that makes thematic sense."
    )
    print_date: str = Field(
        ...,
        description="Print date in format MM/YYYY (e.g., '01/2025') - like Pokemon TCG cards"
    )

    @field_validator("lore_ua")
    @classmethod
    def validate_lore_length(cls, v: str) -> str:
        """Ensure lore is at most 2 sentences."""
        sentences = [s.strip() for s in v.split(".") if s.strip()]
        if len(sentences) > 2:
            logger.warning(
                "Lore exceeds 2 sentences, truncating",
                original_length=len(sentences),
            )
            return ". ".join(sentences[:2]) + "."
        return v


class CardArchitectService:
    """Service for generating card blueprints using Google Gemini AI."""

    def __init__(self, gemini_api_key: str | None = None) -> None:
        """
        Initialize CardArchitectService.

        Args:
            gemini_api_key: Google Gemini API key. If None, uses settings.gemini_api_key.
        """
        api_key = gemini_api_key or settings.gemini_api_key
        if not api_key:
            raise ValueError("GEMINI_API_KEY is required")

        self._api_key = api_key
        self._client = genai.Client(api_key=self._api_key)
        self._model_id = settings.text_model_id

        # System instruction for Gemini
        self._system_instruction = """You are a creative card architect for "Ð¥Ñ€Ð¾Ð½Ñ–ÐºÐ¸ ÐŸÐ¾Ð¼Ð¸Ð¹ÐºÐ¸" (Chronicles of the Dumpster), a Ukrainian Telegram card game bot.

Your task is to generate unique, engaging card blueprints based on user context logs (conversation history, messages, interactions).

PHOTO ANALYSIS (CRITICAL):
- If a photo/image is provided in the context, you MUST analyze it carefully and base the card's description, lore, and visual prompt on what you see in the photo
- The photo content should be the PRIMARY source for card generation - describe what's actually visible in the image
- The lore_ua should accurately describe what's shown in the photo (people, objects, setting, mood, etc.)
- The raw_image_prompt_en should describe the visual elements you see in the photo
- The card_name_ua should be inspired by what's in the photo
- User messages and context are SECONDARY when a photo is provided - use them only for supplementary thematic elements
- If no photo is provided, base the card on user messages and context as usual

CRITICAL: You MUST output valid JSON that exactly matches the CardBlueprint schema. The output must be parseable JSON with no additional text, markdown formatting, or code blocks.

CardBlueprint Schema Requirements:
- target_user_id: integer (the user ID from context)
- card_name_ua: string (card name in Ukrainian, creative and thematic)
- rarity: string enum - must be one of: "Common", "Rare", "Epic", "Legendary", "Mythic"
- biome: string enum - must be one of: "Ð—Ð²Ð¸Ñ‡Ð°Ð¹Ð½Ð¸Ð¹", "Ð’Ð¾Ð³Ð½ÑÐ½Ð¸Ð¹", "Ð’Ð¾Ð´Ð½Ð¸Ð¹", "Ð¢Ñ€Ð°Ð²'ÑÐ½Ð¸Ð¹", "ÐŸÑÐ¸Ñ…Ñ–Ñ‡Ð½Ð¸Ð¹", "Ð¢ÐµÑ…Ð½Ð¾", "Ð¢ÐµÐ¼Ð½Ð¸Ð¹"
- stats_atk: integer (0-100) - attack stat, should correlate with rarity
- stats_def: integer (0-100) - defense stat, should correlate with rarity
- stats_meme: integer (0-100) - meme/humor stat, reflects the playful nature of the game
- lore_ua: string (maximum 2 sentences in Ukrainian) - brief, thematic lore that fits the card
- raw_image_prompt_en: string (English) - descriptive prompt for visual elements ONLY, no game mechanics or stats, focus on appearance, style, mood, colors, composition
- dominant_color_hex: string (hex format like "#FF5733") - primary color for gradients and card accents, should match the card's theme and biome
- accent_color_hex: string (hex format like "#33FF57") - secondary color for highlights and details, should complement the dominant color
- attacks: array of attack objects - Each attack must have: name (Ukrainian), type (one of: "PHYSICAL", "FIRE", "WATER", "GRASS", "PSYCHIC", "TECHNO", "DARK", "MEME"), damage (0-100), energy_cost (1-3), effect (optional string description), status_effect (optional, one of: "NONE", "BURNED", "POISONED", "PARALYZED", "CONFUSED", "ASLEEP", "FROZEN"). Cards should have 1-2 attacks based on rarity (Common: 1, Rare+: 2)
- weakness: object or null - If present: {"type": AttackType enum, "multiplier": float (typically 2.0)}. Cards should have a weakness to one attack type that makes thematic sense (e.g., Fire weak to Water)
- resistance: object or null - If present: {"type": AttackType enum, "reduction": int (typically 10-30)}. Cards may have resistance to one attack type that makes thematic sense
- print_date: string (format "MM/YYYY") - Current month and year when card is printed, like real Pokemon TCG cards (e.g., "01/2025" for January 2025)

Card Name Requirements:
- Card names should be creative and thematic, based on the context provided (messages, personality traits, interests, communication style, photos, descriptions)
- User name/identity is provided as context but does NOT need to be incorporated into the card name
- Generate unique, memorable names that capture the essence of what makes this card special - they can be completely original and creative
- Names should be in Ukrainian and reflect the card's theme, personality, concept, or the context provided
- If a custom description is provided, use that as primary inspiration for the card name
- Be creative and thematic - names can reference concepts, themes, personality traits, or be completely original based on the context

Rarity Guidelines:
- Common: stats 0-30, simple concepts
- Rare: stats 20-50, more interesting concepts
- Epic: stats 40-70, unique and powerful concepts
- Legendary: stats 60-85, exceptional and memorable concepts
- Mythic: stats 75-100, legendary-tier concepts with maximum impact

Biome Selection:
Choose the biome that best fits the card's theme based on the user context. Consider the mood, setting, and thematic elements from the conversation.

Stats Balance:
Ensure stats are balanced and make sense for the rarity. Higher rarity should generally have higher stats, but creativity and thematic fit are more important than pure power.

Lore:
Write engaging, brief lore in Ukrainian (2 sentences maximum) that captures the essence of the card and connects to the user's context.

Image Prompt:
Create a detailed visual description in English that focuses purely on visual elements: appearance, art style, color palette, mood, composition, details. Do NOT include game mechanics, stats, or text elements.

Attack System (Pokemon TCG-inspired):
- Each card should have 1-2 attacks based on rarity (Common: 1 attack, Rare+: 2 attacks)
- Attack types should match the card's biome when possible (Fire biome -> Fire attacks, etc.)
- Energy cost: 1-3 (higher rarity = can have higher energy cost attacks)
- Damage should correlate with rarity and energy cost
- Status effects should be thematic (Fire attacks -> BURNED, Dark attacks -> CONFUSED, etc.)
- Weakness/Resistance should make thematic sense (Fire weak to Water, Water weak to Grass, etc.)

Output Format:
Return ONLY valid JSON matching the CardBlueprint schema. No markdown, no code blocks, no explanations."""

        logger.info(
            "CardArchitectService initialized",
            model=self._model_id,
        )

    def generate_blueprint(
        self, user_context_logs: list[str], custom_image_bytes: Optional[bytes] = None
    ) -> CardBlueprint:
        """
        Generate a card blueprint based on user context logs.

        Args:
            user_context_logs: List of context strings (messages, interactions, etc.)
            custom_image_bytes: Optional image bytes to include in the context (e.g., custom photo from user)

        Returns:
            CardBlueprint instance with generated card data.

        Raises:
            ValueError: If API key is not configured or generation fails after retries.
            ValidationError: If generated JSON doesn't match schema (after retry).
        """
        # Get current month/year for print_date
        now = datetime.now()
        current_print_date = now.strftime("%m/%Y")
        
        # Build user message from context logs
        # If image is provided, emphasize it in the prompt
        if custom_image_bytes:
            user_message = "\n".join(
                [
                    "ðŸ“¸ PHOTO PROVIDED - ANALYZE IT CAREFULLY!",
                    "The photo/image attached above is the PRIMARY source for this card.",
                    "Base the card name, lore, and visual description on what you see in the photo.",
                    "",
                    "User Context Logs (use as SECONDARY context):",
                    "---",
                    *user_context_logs,
                    "---",
                    f"CRITICAL: The print_date field MUST be set to exactly '{current_print_date}' (current month/year in MM/YYYY format). Do not use any other date.",
                    f"Generate a card blueprint based on the PHOTO FIRST, then context. Set print_date to '{current_print_date}' (current month/year).",
                ]
            )
        else:
            user_message = "\n".join(
                [
                    "User Context Logs:",
                    "---",
                    *user_context_logs,
                    "---",
                    f"CRITICAL: The print_date field MUST be set to exactly '{current_print_date}' (current month/year in MM/YYYY format). Do not use any other date.",
                    f"Generate a card blueprint based on this context. Set print_date to '{current_print_date}' (current month/year).",
                ]
            )

        max_retries = 2
        last_error: Optional[Exception] = None

        for attempt in range(max_retries):
            try:
                logger.debug(
                    "Generating card blueprint",
                    attempt=attempt + 1,
                    max_retries=max_retries,
                    context_logs_count=len(user_context_logs),
                    has_custom_image=custom_image_bytes is not None,
                )

                # Build contents array - can include both text and image
                contents = []
                
                # Add image if provided (multimodal input)
                if custom_image_bytes:
                    # Detect image format
                    import base64
                    mime_type = "image/jpeg"  # Default
                    if custom_image_bytes[:2] == b'\xff\xd8':
                        mime_type = "image/jpeg"
                    elif custom_image_bytes[:8] == b'\x89PNG\r\n\x1a\n':
                        mime_type = "image/png"
                    elif custom_image_bytes[:4] == b'RIFF' and custom_image_bytes[8:12] == b'WEBP':
                        mime_type = "image/webp"
                    
                    # Add image as inline data
                    contents.append({
                        "inline_data": {
                            "mime_type": mime_type,
                            "data": base64.b64encode(custom_image_bytes).decode('utf-8')
                        }
                    })
                    logger.debug("Added custom image to blueprint generation context")
                
                # Add text message
                contents.append(user_message)

                # Use unified SDK with v1.56+ features: native Pydantic support and thinking config
                response = self._client.models.generate_content(
                    model=self._model_id,
                    contents=contents,
                    config=types.GenerateContentConfig(
                        system_instruction=self._system_instruction,
                        # Native Pydantic support in v1.56+
                        response_schema=CardBlueprint,
                        response_mime_type="application/json",
                        # Enable Gemini 3.0 "Thinking" (Reasoning)
                        # "medium" offers the best balance for a game (smarter than low, faster than high)
                        thinking_config=types.ThinkingConfig(
                            include_thoughts=False,
                            thinking_level="medium"
                        ),
                        temperature=1.0,
                    )
                )

                if not response.parsed:
                    raise ValueError("Gemini 3 failed to return a valid blueprint.")

                blueprint = response.parsed

                logger.info(
                    "Card blueprint generated successfully",
                    card_name=blueprint.card_name_ua,
                    rarity=blueprint.rarity.value,
                    biome=blueprint.biome.value,
                    target_user_id=blueprint.target_user_id,
                )

                return blueprint

            except Exception as e:
                last_error = e
                logger.warning(
                    "Failed to generate or validate blueprint",
                    attempt=attempt + 1,
                    error=str(e),
                    exc_info=True,
                )

                if attempt < max_retries - 1:
                    logger.info("Retrying blueprint generation")
                    continue

        # If we get here, all retries failed
        logger.error(
            "Failed to generate valid blueprint after retries",
            max_retries=max_retries,
            error=str(last_error) if last_error else "Unknown error",
        )
        raise ValueError(
            f"Failed to generate valid card blueprint after {max_retries} attempts: {last_error}"
        ) from last_error
