"""AI service for generating card blueprints using Google Gemini."""

from typing import Optional

from google import genai
from google.genai import types
from pydantic import BaseModel, Field, field_validator

from config import settings
from database.enums import AttackType, BiomeType, Rarity, StatusEffect
from logging_config import get_logger

logger = get_logger(__name__)


class CardBlueprint(BaseModel):
    """Pydantic model for card blueprint generated by AI."""

    target_user_id: int = Field(..., description="Target user ID for the card")
    card_name_ua: str = Field(..., description="Card name in Ukrainian")
    rarity: Rarity = Field(..., description="Card rarity level")
    biome: BiomeType = Field(..., description="Card biome type")
    stats_atk: int = Field(..., ge=0, le=100, description="Attack stat (0-100)")
    stats_def: int = Field(..., ge=0, le=100, description="Defense stat (0-100)")
    stats_meme: int = Field(..., ge=0, le=100, description="Meme stat (0-100)")
    lore_ua: str = Field(
        ..., max_length=500, description="Card lore in Ukrainian (2 sentences max)"
    )
    raw_image_prompt_en: str = Field(
        ..., description="Descriptive prompt for visual elements only (English)"
    )
    dominant_color_hex: str = Field(
        ..., description="Primary color for gradients and accents (hex format, e.g., #FF5733)"
    )
    accent_color_hex: str = Field(
        ..., description="Secondary color for highlights and details (hex format, e.g., #33FF57)"
    )
    attacks: list[dict] = Field(
        default_factory=list,
        description="List of attacks. Each attack: {\"name\": str (Ukrainian), \"type\": AttackType enum, \"damage\": int (0-100), \"energy_cost\": int (1-3), \"effect\": str (optional description), \"status_effect\": StatusEffect enum (optional)}"
    )
    weakness: dict | None = Field(
        default=None,
        description="Weakness to attack type: {\"type\": AttackType enum, \"multiplier\": float (typically 2.0)}"
    )
    resistance: dict | None = Field(
        default=None,
        description="Resistance to attack type: {\"type\": AttackType enum, \"reduction\": int (typically 10-30)}"
    )
    print_date: str = Field(
        ...,
        description="Print date in format MM/YYYY (e.g., '01/2025') - like Pokemon TCG cards"
    )

    @field_validator("lore_ua")
    @classmethod
    def validate_lore_length(cls, v: str) -> str:
        """Ensure lore is at most 2 sentences."""
        sentences = [s.strip() for s in v.split(".") if s.strip()]
        if len(sentences) > 2:
            logger.warning(
                "Lore exceeds 2 sentences, truncating",
                original_length=len(sentences),
            )
            return ". ".join(sentences[:2]) + "."
        return v


class CardArchitectService:
    """Service for generating card blueprints using Google Gemini AI."""

    def __init__(self, gemini_api_key: str | None = None) -> None:
        """
        Initialize CardArchitectService.

        Args:
            gemini_api_key: Google Gemini API key. If None, uses settings.gemini_api_key.
        """
        api_key = gemini_api_key or settings.gemini_api_key
        if not api_key:
            raise ValueError("GEMINI_API_KEY is required")

        self._api_key = api_key
        self._client = genai.Client(api_key=self._api_key)
        self._model_id = settings.text_model_id

        # System instruction for Gemini
        self._system_instruction = """You are a creative card architect for "Хроніки Помийки" (Chronicles of the Dumpster), a Ukrainian Telegram card game bot.

Your task is to generate unique, engaging card blueprints based on user context logs (conversation history, messages, interactions).

CRITICAL: You MUST output valid JSON that exactly matches the CardBlueprint schema. The output must be parseable JSON with no additional text, markdown formatting, or code blocks.

CardBlueprint Schema Requirements:
- target_user_id: integer (the user ID from context)
- card_name_ua: string (card name in Ukrainian, creative and thematic)
- rarity: string enum - must be one of: "Common", "Rare", "Epic", "Legendary", "Mythic"
- biome: string enum - must be one of: "Звичайний", "Вогняний", "Водний", "Трав'яний", "Психічний", "Техно", "Темний"
- stats_atk: integer (0-100) - attack stat, should correlate with rarity
- stats_def: integer (0-100) - defense stat, should correlate with rarity
- stats_meme: integer (0-100) - meme/humor stat, reflects the playful nature of the game
- lore_ua: string (maximum 2 sentences in Ukrainian) - brief, thematic lore that fits the card
- raw_image_prompt_en: string (English) - descriptive prompt for visual elements ONLY, no game mechanics or stats, focus on appearance, style, mood, colors, composition
- dominant_color_hex: string (hex format like "#FF5733") - primary color for gradients and card accents, should match the card's theme and biome
- accent_color_hex: string (hex format like "#33FF57") - secondary color for highlights and details, should complement the dominant color
- attacks: array of attack objects - Each attack must have: name (Ukrainian), type (one of: "PHYSICAL", "FIRE", "WATER", "GRASS", "PSYCHIC", "TECHNO", "DARK", "MEME"), damage (0-100), energy_cost (1-3), effect (optional string description), status_effect (optional, one of: "NONE", "BURNED", "POISONED", "PARALYZED", "CONFUSED", "ASLEEP", "FROZEN"). Cards should have 1-2 attacks based on rarity (Common: 1, Rare+: 2)
- weakness: object or null - If present: {"type": AttackType enum, "multiplier": float (typically 2.0)}. Cards should have a weakness to one attack type that makes thematic sense (e.g., Fire weak to Water)
- resistance: object or null - If present: {"type": AttackType enum, "reduction": int (typically 10-30)}. Cards may have resistance to one attack type that makes thematic sense
- print_date: string (format "MM/YYYY") - Current month and year when card is printed, like real Pokemon TCG cards (e.g., "01/2025" for January 2025)

Card Name Requirements:
- CRITICAL: If a user name/identity is provided in the context, the card name MUST be based on or incorporate that user's name/persona
- The card name should creatively reflect the user's identity, not just generic concepts from their messages
- Example: If user name is "Келих Вина" (Wine Glass), the card name should incorporate or reference this identity (e.g., "Келих Вина", "Винний Келих", "Келих Війни", etc.)
- The card name should be in Ukrainian and reflect the user's persona based on their name

Rarity Guidelines:
- Common: stats 0-30, simple concepts
- Rare: stats 20-50, more interesting concepts
- Epic: stats 40-70, unique and powerful concepts
- Legendary: stats 60-85, exceptional and memorable concepts
- Mythic: stats 75-100, legendary-tier concepts with maximum impact

Biome Selection:
Choose the biome that best fits the card's theme based on the user context. Consider the mood, setting, and thematic elements from the conversation.

Stats Balance:
Ensure stats are balanced and make sense for the rarity. Higher rarity should generally have higher stats, but creativity and thematic fit are more important than pure power.

Lore:
Write engaging, brief lore in Ukrainian (2 sentences maximum) that captures the essence of the card and connects to the user's context.

Image Prompt:
Create a detailed visual description in English that focuses purely on visual elements: appearance, art style, color palette, mood, composition, details. Do NOT include game mechanics, stats, or text elements.

Attack System (Pokemon TCG-inspired):
- Each card should have 1-2 attacks based on rarity (Common: 1 attack, Rare+: 2 attacks)
- Attack types should match the card's biome when possible (Fire biome -> Fire attacks, etc.)
- Energy cost: 1-3 (higher rarity = can have higher energy cost attacks)
- Damage should correlate with rarity and energy cost
- Status effects should be thematic (Fire attacks -> BURNED, Dark attacks -> CONFUSED, etc.)
- Weakness/Resistance should make thematic sense (Fire weak to Water, Water weak to Grass, etc.)

Output Format:
Return ONLY valid JSON matching the CardBlueprint schema. No markdown, no code blocks, no explanations."""

        logger.info(
            "CardArchitectService initialized",
            model=self._model_id,
        )

    def generate_blueprint(self, user_context_logs: list[str]) -> CardBlueprint:
        """
        Generate a card blueprint based on user context logs.

        Args:
            user_context_logs: List of context strings (messages, interactions, etc.)

        Returns:
            CardBlueprint instance with generated card data.

        Raises:
            ValueError: If API key is not configured or generation fails after retries.
            ValidationError: If generated JSON doesn't match schema (after retry).
        """
        # Get current month/year for print_date
        now = datetime.now()
        current_print_date = now.strftime("%m/%Y")
        
        # Build user message from context logs
        user_message = "\n".join(
            [
                "User Context Logs:",
                "---",
                *user_context_logs,
                "---",
                f"Generate a card blueprint based on this context. Set print_date to '{current_print_date}' (current month/year).",
            ]
        )

        max_retries = 2
        last_error: Optional[Exception] = None

        for attempt in range(max_retries):
            try:
                logger.debug(
                    "Generating card blueprint",
                    attempt=attempt + 1,
                    max_retries=max_retries,
                    context_logs_count=len(user_context_logs),
                )

                # Use unified SDK with v1.56+ features: native Pydantic support and thinking config
                response = self._client.models.generate_content(
                    model=self._model_id,
                    contents=user_message,
                    config=types.GenerateContentConfig(
                        system_instruction=self._system_instruction,
                        # Native Pydantic support in v1.56+
                        response_schema=CardBlueprint,
                        response_mime_type="application/json",
                        # Enable Gemini 3.0 "Thinking" (Reasoning)
                        # "medium" offers the best balance for a game (smarter than low, faster than high)
                        thinking_config=types.ThinkingConfig(
                            include_thoughts=False,
                            thinking_level="medium"
                        ),
                        temperature=1.0,
                    )
                )

                if not response.parsed:
                    raise ValueError("Gemini 3 failed to return a valid blueprint.")

                blueprint = response.parsed

                logger.info(
                    "Card blueprint generated successfully",
                    card_name=blueprint.card_name_ua,
                    rarity=blueprint.rarity.value,
                    biome=blueprint.biome.value,
                    target_user_id=blueprint.target_user_id,
                )

                return blueprint

            except Exception as e:
                last_error = e
                logger.warning(
                    "Failed to generate or validate blueprint",
                    attempt=attempt + 1,
                    error=str(e),
                    exc_info=True,
                )

                if attempt < max_retries - 1:
                    logger.info("Retrying blueprint generation")
                    continue

        # If we get here, all retries failed
        logger.error(
            "Failed to generate valid blueprint after retries",
            max_retries=max_retries,
            error=str(last_error) if last_error else "Unknown error",
        )
        raise ValueError(
            f"Failed to generate valid card blueprint after {max_retries} attempts: {last_error}"
        ) from last_error
