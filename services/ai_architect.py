"""AI service for generating card blueprints using Google Gemini."""

from typing import Optional

from google import genai
from google.genai import types
from pydantic import BaseModel, Field, field_validator

from config import settings
from database.enums import BiomeType, Rarity
from logging_config import get_logger

logger = get_logger(__name__)


class CardBlueprint(BaseModel):
    """Pydantic model for card blueprint generated by AI."""

    target_user_id: int = Field(..., description="Target user ID for the card")
    card_name_ua: str = Field(..., description="Card name in Ukrainian")
    rarity: Rarity = Field(..., description="Card rarity level")
    biome: BiomeType = Field(..., description="Card biome type")
    stats_atk: int = Field(..., ge=0, le=100, description="Attack stat (0-100)")
    stats_def: int = Field(..., ge=0, le=100, description="Defense stat (0-100)")
    stats_meme: int = Field(..., ge=0, le=100, description="Meme stat (0-100)")
    lore_ua: str = Field(
        ..., max_length=500, description="Card lore in Ukrainian (2 sentences max)"
    )
    raw_image_prompt_en: str = Field(
        ..., description="Descriptive prompt for visual elements only (English)"
    )

    @field_validator("lore_ua")
    @classmethod
    def validate_lore_length(cls, v: str) -> str:
        """Ensure lore is at most 2 sentences."""
        sentences = [s.strip() for s in v.split(".") if s.strip()]
        if len(sentences) > 2:
            logger.warning(
                "Lore exceeds 2 sentences, truncating",
                original_length=len(sentences),
            )
            return ". ".join(sentences[:2]) + "."
        return v


class CardArchitectService:
    """Service for generating card blueprints using Google Gemini AI."""

    def __init__(self, gemini_api_key: str | None = None) -> None:
        """
        Initialize CardArchitectService.

        Args:
            gemini_api_key: Google Gemini API key. If None, uses settings.gemini_api_key.
        """
        api_key = gemini_api_key or settings.gemini_api_key
        if not api_key:
            raise ValueError("GEMINI_API_KEY is required")

        self._api_key = api_key
        self._client = genai.Client(api_key=self._api_key)
        self._model_id = settings.text_model_id

        # System instruction for Gemini
        self._system_instruction = """You are a creative card architect for "Хроніки Помийки" (Chronicles of the Dumpster), a Ukrainian Telegram card game bot.

Your task is to generate unique, engaging card blueprints based on user context logs (conversation history, messages, interactions).

CRITICAL: You MUST output valid JSON that exactly matches the CardBlueprint schema. The output must be parseable JSON with no additional text, markdown formatting, or code blocks.

CardBlueprint Schema Requirements:
- target_user_id: integer (the user ID from context)
- card_name_ua: string (card name in Ukrainian, creative and thematic)
- rarity: string enum - must be one of: "Common", "Rare", "Epic", "Legendary", "Mythic"
- biome: string enum - must be one of: "Звичайний", "Вогняний", "Водний", "Трав'яний", "Психічний", "Техно", "Темний"
- stats_atk: integer (0-100) - attack stat, should correlate with rarity
- stats_def: integer (0-100) - defense stat, should correlate with rarity
- stats_meme: integer (0-100) - meme/humor stat, reflects the playful nature of the game
- lore_ua: string (maximum 2 sentences in Ukrainian) - brief, thematic lore that fits the card
- raw_image_prompt_en: string (English) - descriptive prompt for visual elements ONLY, no game mechanics or stats, focus on appearance, style, mood, colors, composition

Rarity Guidelines:
- Common: stats 0-30, simple concepts
- Rare: stats 20-50, more interesting concepts
- Epic: stats 40-70, unique and powerful concepts
- Legendary: stats 60-85, exceptional and memorable concepts
- Mythic: stats 75-100, legendary-tier concepts with maximum impact

Biome Selection:
Choose the biome that best fits the card's theme based on the user context. Consider the mood, setting, and thematic elements from the conversation.

Stats Balance:
Ensure stats are balanced and make sense for the rarity. Higher rarity should generally have higher stats, but creativity and thematic fit are more important than pure power.

Lore:
Write engaging, brief lore in Ukrainian (2 sentences maximum) that captures the essence of the card and connects to the user's context.

Image Prompt:
Create a detailed visual description in English that focuses purely on visual elements: appearance, art style, color palette, mood, composition, details. Do NOT include game mechanics, stats, or text elements.

Output Format:
Return ONLY valid JSON matching the CardBlueprint schema. No markdown, no code blocks, no explanations."""

        logger.info(
            "CardArchitectService initialized",
            model=self._model_id,
        )

    def generate_blueprint(self, user_context_logs: list[str]) -> CardBlueprint:
        """
        Generate a card blueprint based on user context logs.

        Args:
            user_context_logs: List of context strings (messages, interactions, etc.)

        Returns:
            CardBlueprint instance with generated card data.

        Raises:
            ValueError: If API key is not configured or generation fails after retries.
            ValidationError: If generated JSON doesn't match schema (after retry).
        """
        # Build user message from context logs
        user_message = "\n".join(
            [
                "User Context Logs:",
                "---",
                *user_context_logs,
                "---",
                "Generate a card blueprint based on this context.",
            ]
        )

        max_retries = 2
        last_error: Optional[Exception] = None

        for attempt in range(max_retries):
            try:
                logger.debug(
                    "Generating card blueprint",
                    attempt=attempt + 1,
                    max_retries=max_retries,
                    context_logs_count=len(user_context_logs),
                )

                # Use unified SDK with JSON schema enforcement
                # Build contents as a simple string (the SDK will handle conversion)
                # Note: Using default thinking level for Gemini 3 Flash (usually "Dynamic")
                # to avoid 400 Bad Request errors until SDK fully supports explicit thinking_config
                response = self._client.models.generate_content(
                    model=self._model_id,
                    contents=user_message,
                    config=types.GenerateContentConfig(
                        system_instruction=self._system_instruction,
                        response_mime_type="application/json",
                        response_schema=CardBlueprint.model_json_schema()
                    )
                )

                if not response.candidates:
                    raise ValueError("Empty response from Gemini API")

                # Extract text from response
                candidate = response.candidates[0]
                if not hasattr(candidate, "content") or not candidate.content:
                    raise ValueError("No content in response")

                if not hasattr(candidate.content, "parts") or not candidate.content.parts:
                    raise ValueError("No parts in content")

                # Get text from parts
                text_parts = [
                    part.text for part in candidate.content.parts
                    if hasattr(part, "text") and part.text
                ]

                if not text_parts:
                    raise ValueError("No text in response parts")

                response_text = "".join(text_parts)

                # Try to use parsed response if available, otherwise parse manually
                if hasattr(response, "parsed") and response.parsed:
                    blueprint = CardBlueprint.model_validate(response.parsed)
                else:
                    # Parse JSON response into CardBlueprint
                    blueprint = CardBlueprint.model_validate_json(response_text)

                logger.info(
                    "Card blueprint generated successfully",
                    card_name=blueprint.card_name_ua,
                    rarity=blueprint.rarity.value,
                    biome=blueprint.biome.value,
                    target_user_id=blueprint.target_user_id,
                )

                return blueprint

            except Exception as e:
                last_error = e
                logger.warning(
                    "Failed to generate or validate blueprint",
                    attempt=attempt + 1,
                    error=str(e),
                    exc_info=True,
                )

                if attempt < max_retries - 1:
                    logger.info("Retrying blueprint generation")
                    continue

        # If we get here, all retries failed
        logger.error(
            "Failed to generate valid blueprint after retries",
            max_retries=max_retries,
            error=str(last_error) if last_error else "Unknown error",
        )
        raise ValueError(
            f"Failed to generate valid card blueprint after {max_retries} attempts: {last_error}"
        ) from last_error
