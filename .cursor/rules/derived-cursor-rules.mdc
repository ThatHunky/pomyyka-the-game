---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## PROJECT RULES

*   Project name: –•—Ä–æ–Ω—ñ–∫–∏ –ü–æ–º–∏–π–∫–∏ (Chronicles of the Dumpster) - A Ukrainian Telegram Card Game Bot.
*   Target Locale: Ukrainian ("uk")

## TECH STACK

*   Python: 3.14
*   aiogram: 3.x -> 3.17 (>=3.17,<4.0)
*   SQLAlchemy: Async
*   PostgreSQL: 17-alpine
*   Redis: alpine
*   Docker Compose
*   pydantic-settings
*   asyncpg
*   alembic
*   apscheduler
*   google-genai: >=1.0.0 -> 1.56.0 (Strict versioning)
*   pydantic: >=2.10 (>=2.10,<3.0)
*   redis: ^5.2.0 (>=5.2.0,<6.0)
*   Pillow >=10.0.0
*   imageio[ffmpeg] >=2.31.0 (For MP4 encoding) OR opencv-python>=4.8.0 (Alternative video encoding option) Requires ffmpeg binary to be installed on the system.

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   `.env.example`: Contains example environment variables: `BOT_TOKEN` (required), `DB_URL` (required), `REDIS_URL` (required), `GEMINI_API_KEY` (optional, bot can run without it), `LOCALE` (defaults to "uk"), `ADMIN_USER_IDS` (comma-separated list of Telegram user IDs, for admin authentication).
*   Context: Using the "Gemini 3.0" feature set which requires the 1.56 SDK.
*   Game Design Document (GDD): `plan-doc.md` - a complete map of mechanics, economics, and logic, which combines already written code with new ideas (trading, currency, battles).
*   Chat Export Format: Telegram JSON export (result.json from Telegram Desktop).
*   Chat Export Location: `data/chat_exports/` directory. Place `result.json` files from Telegram Desktop exports there.
*   To make the `data/chat_exports` folder accessible from the container, add a volume mount in `docker-compose.yml` to mount the directory on the host to `/app/data/chat_exports` inside the container:
    ```yaml
    volumes:
      - ./data/chat_exports:/app/data/chat_exports
    ```
    *   The `data/chat_exports` directory on the host is mounted into the container at `/app/data/chat_exports/`. Place JSON files in `data/chat_exports/` on your host machine, and they are automatically accessible inside the container at `/app/data/chat_exports/`. No need to copy files into the container or rebuild images.
*   The contents of the chat export folder (specifically *.json and *.txt files) must be added to `.gitignore`.
*   Card Placeholder Specification: `CARD_PLACEHOLDER_SPEC.md` - Defines the layout, data fields, and visual style for generating a placeholder card image resembling Pokemon TCG cards, used for generative editing.
    *   The specification includes the following fields: Card Name, Rarity Indicator, Biome Type, Artwork Area, Attack Stat (ATK), Defense Stat (DEF), Meme Stat, Lore/Flavor Text.
    *   **Rarity Indicators**:
        *   Common (‚ö™)
        *   Rare (üîµ)
        *   Epic (üü£)
        *   Legendary (üü†)
        *   Mythic (üî¥)
    *   **Biome Types**:
        *   –ó–≤–∏—á–∞–π–Ω–∏–π (üåç)
        *   –í–æ–≥–Ω—è–Ω–∏–π (üî•)
        *   –í–æ–¥–Ω–∏–π (üíß)
        *   –¢—Ä–∞–≤'—è–Ω–∏–π (üåø)
        *   –ü—Å–∏—Ö—ñ—á–Ω–∏–π (üîÆ)
        *   –¢–µ—Ö–Ω–æ (‚öôÔ∏è)
        *   –¢–µ–º–Ω–∏–π (üåë)
*   Card Placeholder Files: Empty `.png` files (with transparent backgrounds) for different card types (biome/rarity/type) are located in dedicated folders. These placeholders will be replaced with generated content.
    *   Placeholders should be named with the format: `assets/placeholders/{biome}_{rarity}.png`.
    *   Both PNG and WebP versions are now available in `assets/placeholders/`. The `nano_banana.py` service currently uses PNG files, so you may want to update it to use WebP for production.
*   AI Studio Prompts: `PROMPTS_FOR_AI_STUDIO.md` - Contains JSON prompts for generating card template placeholders using Gemini / Imagen 3 in AI Studio.
    *   The file contains JSON prompts for generating card template placeholders using Gemini / Imagen 3 in AI Studio.
    *   To use the prompts:
        1.  Copy the `prompt` text for the specific card template you want to generate.
        2.  Go to [Google AI Studio](https://aistudio.google.com/).
        3.  Select the **Imagen 3** model (or latest image generation model).
        4.  Paste the prompt into the prompt box.
        5.  Set aspect ratio to **Portrait** (3:4) or similar vertical ratio.
        6.  Generate the image.
        7.  Save the image as the corresponding `filename` in `assets/placeholders/`.
    *   The prompts now include the following EXACT layout and text labels:
        *   Biome indicators: `üåç –ó–≤–∏—á–∞–π–Ω–∏–π`, `üî• –í–æ–≥–Ω—è–Ω–∏–π`, `üíß –í–æ–¥–Ω–∏–π`, `üåø –¢—Ä–∞–≤'—è–Ω–∏–π`, `üîÆ –ü—Å–∏—Ö—ñ—á–Ω–∏–π`, `‚öôÔ∏è –¢–µ—Ö–Ω–æ`, `üåë –¢–µ–º–Ω–∏–π`
        *   Rarity indicators: `‚ö™ COMMON`, `üîµ RARE`, `üü£ EPIC`, `üü† LEGENDARY`, `üî¥ MYTHIC`
        *   Card name placeholder: `"–ù–ê–ó–í–ê –ö–ê–†–¢–ö–ò"`
        *   Lore text: `"–¶–µ –æ–ø–∏—Å–æ–≤–∞ —á–∞—Å—Ç–∏–Ω–∞ –∫–∞—Ä—Ç–∫–∏. –í–æ–Ω–∞ –º—ñ—Å—Ç–∏—Ç—å –ª–æ—Ä —Ç–∞ —ñ—Å—Ç–æ—Ä—ñ—é –ø–µ—Ä—Å–æ–Ω–∞–∂–∞."`
        *   Stats with emojis: `‚öîÔ∏è ATK: 50`, `üé≠ MEME: 50`, `üõ°Ô∏è DEF: 50`
    *   Each card template includes the following sections (Pokemon TCG style):
        1.  **Header**: Biome indicator (top left), Card name (top center), Rarity indicator (top right)
        2.  **Artwork Area**: Large center section for character/creature illustration
        3.  **Attacks Section**: 1-2 attacks with energy cost, damage, and effect descriptions
            *   Common cards: 1 attack
            *   Rare+ cards: 2 attacks
            *   Format: Attack name [energy icons] damage
            *   Effect text below each attack in small italic font
        4.  **Lore**: Flavor text in Ukrainian (small italic font)
        5.  **Stats**: ATK (left), MEME (center), DEF (right)
        6.  **Footer**: Weakness (bottom left), Resistance (bottom right), Print date (bottom center)

## CODING STANDARDS

*   Use `pydantic-settings` for configuration management.
*   Output logs in JSON format using `structlog`.
*   The application must be runnable without the Gemini API key being present (manual adding is acceptable). When `GEMINI_API_KEY` is not provided, Gemini-related functionality should be gracefully disabled.
*   When tracking group chats in `middlewares/group_tracker.py`, use PostgreSQL's `INSERT ON CONFLICT DO NOTHING` to prevent errors when the bot joins a group it has already been in.
*   All Admin prompts should be in Ukrainian.
*   Escape special Markdown V2 characters in user-provided content (card names, usernames, rarity/biome values, user first names) to prevent parsing errors. Use `utils/text.py` with `escape_markdown()`.
*   The bot should primarily edit messages instead of sending new ones to reduce spam. Callback handlers should only edit existing messages, never send new ones.
*   When parsing `ADMIN_USER_IDS` from the environment variables, the validator in `config.py` must handle:
    *   Quoted values (`"392817811"` or `'392817811'`)
    *   Extra whitespace
    *   Invalid entries (log a warning instead of failing)
    *   Single `int` values (e.g., `392817811`)
*   Admin access must be available via username or userID.
*   When using `CallbackData.pack()`, be aware that it uses colons (`:`) as field separators. To avoid `ValueError: Separator symbol ':' can not be used in value` due to Telegram's 64-byte limit on callback data, store the relevant data in Redis using the `SessionManager` and pass only the UUID in the callback.
*   Card Art Style:
    *   The card art style should resemble Pokemon TCG cards, not "cyberpunk trash."
*   Card Generation:
    *   Card generation will use Image Integration Strategy: Option A (AI-driven). The "Nano Banana Pro" (Gemini 3 Pro) model accepts the placeholder and user photo as inputs to generate the final card image directly.
    *   `CardGeneratorService` (formerly `NanoBananaService`) will use group chat photo/user photo (if available) to generate card illustrations.
    *   `CardGeneratorService` should generate appropriate gradient accents for cards.
    *   `CardGeneratorService` must integrate the photo into the card design.
    *   The bot should send 200 random messages from that user (either from imported messages data or group chat messages), filtered to be at least 20 characters long, to the AI architect to inform card design.
    *   When fetching 200 random messages, mix imported `result.json` data and `MessageLog` (DB) if both are available.
*   Getting Group Chat Icon:
    *   Use `bot.get_chat(chat_id)` to get chat object.
    *   Access the `photo` field of the chat object.
    *   Use `bot.get_file()` and `bot.download_file()` to download the image.
*   Getting User Profile Picture:
    *   Use `bot.get_user_profile_photos(user_id=user_id, limit=1)` to get the most recent profile picture.
    *   Use `bot.get_file()` and `bot.download_file()` to download the image.
    *   This works even if the user isn't registered, as long as the bot has access to them and they have a profile picture set.
*   Unique Card IDs:
    *   Each `UserCard` instance must have a unique, short, human-readable ID (`display_id`).
    *   The `display_id` should have the format "POM-XXXX" where XXXX is a 4-character alphanumeric code.
    *   Characters to use for display IDs: `ABCDEFGHJKLMNPQRSTUVWXYZ2346789` (avoiding confusing characters like 0/O, 1/I, 5/S).
*   Card Border Effects:
    *   Cards should have decorative borders based on rarity.
        *   COMMON - Simple light gray border
        *   RARE - Double blue border
        *   EPIC - Ornate purple border with glow and decorative elements
        *   LEGENDARY - Ornate gold/orange border with glow and corner decorations
        *   MYTHIC - Ornate red border with glow and decorative elements
    *   Rounded corners should be applied.
*   Cards are sent as normal images, and animated ones as GIFs (`.mp4`s in Telegram)
    *   For animated cards, use the animated WebP versions
    *   Cards are sent as normal images, and animated ones as GIFs (`.mp4`s in Telegram)
    *   Animated cards (Epic, Legendary, Mythic) should have holographic/glowing effects.
    *   When sending cards:
        *   Common/Rare cards: Send as photos
        *   Epic/Legendary/Mythic cards: Send as MP4 videos (if available) or GIFs (if MP4 unavailable), using `answer_animation` to ensure they play inline like GIFs.

## WORKFLOW & RELEASE RULES

*   Bot should primarily edit messages instead of sending new ones to reduce spam.
*   If running the bot in Docker, restart the container after changing environment variables for the changes to take effect. Use `docker-compose restart bot` or `docker-compose up -d --build bot`.
*   Since `display_id` is a new required field, you'll need to:
    1.  Run a database migration to add the column.
    2.  Populate display IDs for any existing cards in the database.

## DEBUGGING

*   `EditMessageText` expects `InlineKeyboardMarkup`, but a `ReplyKeyboardMarkup` is being passed. Editing messages only supports inline keyboards. Ensure that `safe_edit_text()` and Telegram's `edit_text()` are called with `InlineKeyboardMarkup` when editing messages.
*   When debugging admin command access, check the following:
    *   The `.env` file format should be `ADMIN_USER_IDS=392817811` (no quotes, no spaces around the `=`).
    *   Check the logs at startup to verify what admin IDs were loaded.
    *   When attempting the command, check the logs to see what user ID is being checked and what admin IDs are configured.
*   If the callback data exceeds Telegram's 64-byte limit, store the data in Redis using the `SessionManager` and pass only the UUID in the callback.
*   When editing the photo message caption in `handlers/admin_autocard.py` with `edit_text`, ensure that the `chat_id` and `message_id` are correctly passed and that the caption is properly formatted and escaped. The handlers `handle_autocard_cancel` and `handle_autocard_approve` should be reviewed for potential issues. Specifically:
    *   Ensure that the code checks if the message is a photo (`callback.message.photo`).
    *   Use `edit_caption()` for photo messages.
    *   Use `edit_text()` for text messages.
    *   Ensure all user provided text is escaped using `escape_markdown()`.

## INFRASTRUCTURE

*   Docker Compose should define `bot`, `db` (PostgreSQL), and `redis` services.
*   Docker container must wait for Postgres and Redis to be healthy before starting the bot. This can be achieved through health checks in `docker-compose.yml` and/or retry logic in the Python startup code.
*   Use named volumes for `pg_data` and `redis_data` to persist data.
*   Dockerfile: The `CMD` instruction should be `CMD ["python", "main.py"]` to correctly start the bot application.
*   To make the `data/chat_exports` folder accessible from the container, add a volume mount in `docker-compose.yml` to mount the directory on the host to `/app/data/chat_exports` inside the container:
    ```yaml
    volumes:
      - ./data/chat_exports:/app/data/chat_exports
    ```
    *   The `data/chat_exports` directory on the host is mounted into the container at `/app/data/chat_exports/`. Place JSON files in `data/chat_exports/` on your host machine, and they are automatically accessible inside the container at `/app/data/chat_exports/`. No need to copy files into the container or rebuild images.

## REDIS

*   Utilize `services/redis_lock.py` with a Lua script for atomic operations to prevent race conditions when claiming drops. The Lua script should:
    *   Atomically check if the drop key exists.
    *   If it doesn't, set the key to the user ID, set a TTL, and return 1.
    *   If it does exist, return 0.
*   Use async Redis (`redis.asyncio`) to match the project's async pattern.
*   Load the script once and cache it via SHA.
*   Implement error handling: return `False` on Redis errors to prevent double claims.
*   Implement `DropManager` class in `services/redis_lock.py` with methods:
    *   `try_claim_drop(message_id, user_id, ttl)`
    *   `release_drop()` - manual cleanup
    *   `get_claim_owner()` - check who claimed a drop
    *   `close()` - cleanup connection
*   Implement `services/session_manager.py` to manage trade and battle sessions.
*   The `SessionManager` should also include methods for storing and retrieving blueprint data for autocard flows, using UUIDs as keys. These methods are:
    *   `store_blueprint(blueprint(blueprint_data: dict, ttl: int = 3600) -> str`: Stores blueprint data in Redis for autocard callbacks.
    *   `get_blueprint(blueprint_id: str) -> Optional[dict]`: Gets blueprint data from Redis.
    *   `delete_blueprint(blueprint_id: str) -> bool`: Deletes blueprint data from Redis.

## MIDDLEWARE

*   Implement `middlewares/group_tracker.py` to track group chats.
*   Create `ChatTrackingMiddleware` that intercepts every update.
*   If `chat.type` is `supergroup` or `group`:
    *   Upsert the `GroupChat` table (INSERT ON CONFLICT DO NOTHING). This ensures we have a list of all groups the bot is in.
*   Implement `middlewares/logger.py` to log messages in group chats.
    *   Create a new middleware that runs after `GroupTrackingMiddleware`.
    *   **Logic**: For every text message in a group chat:
        *   Fire-and-forget an async task to insert the message into `MessageLog`.
    *   **Optimization**: Do *not* log commands (starting with `/`).
*   **Middleware Event Handling**: When registering middlewares using `dp.message.middleware()`, the `event` parameter is a `Message` object, not an `Update` object.
*   User registration should be triggered on *any* interaction, not just specific commands like `/start`.
    *   **Implementation**: Modify the `get_or_create_user` function or equivalent to be called in a middleware that intercepts all messages.
    *   Implement `middlewares/user_registration.py` to automatically register users on any interaction (messages, callback queries, etc.).
    *   Register the middleware for both `message` and `callback_query` events.
    *   Uses PostgreSQL `ON CONFLICT DO NOTHING` for thread-safe registration.
    *   After user registration, check if user is admin. If admin, set their commands to include admin commands using `Bot.set_my_commands()`, `BotCommandScopeChat(chat_id=user_id)`, and `get_all_commands()`.

## HANDLERS

*   Create `handlers/drops.py` to handle drop claims.
    *   **Import Fix**: Use `from aiogram.filters.callback_data import CallbackData` instead of `from aiogram.filters import CallbackData`.
        *   **Note**: All handler files (`handlers/drops.py`, `handlers/admin.py`, `handlers/admin_autocard.py`) already use the correct import path: `from aiogram.filters.callback_data import CallbackData`.
    *   **Loop Fix**: In `_award_card_and_update_message`, remove the `finally:` block and move the `break` statement to the end of the `try` block.
    *   **Python 3.14 Safety**: Remove the `finally:` block containing `break`. Instead, place the `break` statement as the last line inside the `try` block.
    *   **User Creation**: When a user claims a drop, the `_award_card_and_update_message` function automatically creates a User record if one doesn't exist.
*   Create `handlers/admin.py` to handle admin commands.
    *   **Import Fix**: Use `from aiogram.filters.callback_data import CallbackData` instead of `from aiogram.filters import CallbackData`.
    *   **Python 3.14 Safety**: Remove the `finally:` block containing `break`. Rely on `get_session()`'s natural termination if it yields only once.
    *   `/import_chat <filename>` - Import chat history from Telegram JSON export.
    *   **Usage**:
        1.  Place the `result.json` file in `data/chat_exports/`
        2.  Run `/import_chat result.json` in the bot.
*   Implement a Callback Query Handler for data `claim_drop`.
*   Call `DropManager.try_claim_drop(message.message_id, user.id)`.
    *   **If Success**:
        *   Award card to user in DB.
        *   Edit message text: "‚úÖ **[User]** –±–ª–∏—Å–∫–∞–≤–∏—á–Ω–æ —Å—Ö–æ–ø–∏–≤ [Card Name]!" (Use Ukrainian).
    *   **If Fail**:
        *   Answer callback query with alert: "‚ùå –•—Ç–æ—Å—å –≤–∏—è–≤–∏–≤—Å—è —Å–ø—Ä–∏—Ç–Ω—ñ—à–∏–º!" (Alert/Toast).
*   Implement Admin Card Creation Flow in `handlers/admin.py`.
    *   **FSM**: States `WaitingForName`, `WaitingForArtPrompt`, `WaitingForStats`.
    *   `/newcard` -> Input Name.
    *   Select Biome (Inline Keyboard of Biomes).
    *   Input Prompt -> Gen Art -> Review.
    *   Input Stats -> Save.
    *   **Nano Banana Integration**:
        *   Use `NanoBananaService` (now `CardGeneratorService`) to generate art.
        *   Prompt: "Trading card art, [User Prompt], style of [Biome Style]".
        *   The `generate_card_image()` function in `handlers/admin.py` generates card image using Nano Banana Pro (Gemini 3 Pro Image).
        *   To complete the image generation, implement the actual API call in `generate_card_image()` based on your image generation service (Nano Banana or another service). The function should return a relative filepath to saved image.
        *   The flow continues even if image generation fails (image_url can be None), allowing cards to be created without images if needed.
*   Implement `handlers/admin_autocard.py`.
    *   Command: `/autocard`
    *   Supports three modes:
        *   Reply mode: `/autocard` (reply to a message)
        *   Username mode: `/autocard @username`
        *   UserID mode: `/autocard 392817811`
    *   **Logic Flow (Async):**
        1.  **Trigger**: Admin replies `/autocard` to a user message, or uses `/autocard @username` or `/autocard userID`.
        2.  **Feedback**: Bot sends "üïµÔ∏è‚Äç‚ôÇÔ∏è –ê–Ω–∞–ª—ñ–∑—É—é –æ—Å–æ–±–∏—Å—Ç—ñ—Å—Ç—å [User]..." (Analyzing personality...).
        3.  **Fetch Context**:
            *   DB Query: Select last 50 messages from `MessageLog` for this `target_user_id`.
            *   Flatten into a list of strings.
        4.  **Architect Step**:
            *   Bot edits message: "üß† –ü—Ä–æ—î–∫—Ç—É—é –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É –∫–∞—Ä—Ç–∫–∏..." (Designing card architecture...).
            *   Call `CardArchitectService.generate_blueprint(logs, target_user_id, target_user_name)`. Pass the `target_user_id` and `target_user_name` to the service.
        5.  **Art Forge Step**:
            *   Bot edits message: "üé® –ö—É—é –≤—ñ–∑—É–∞–ª —É –Ω–∞–Ω–æ-–≥–æ—Ä–Ω—ñ..." (Forging visuals in –Ω–∞–Ω–æ-–≥–æ—Ä–Ω—ñ...).
            *   Call `ArtForgeService.forge_card_image(blueprint.raw_image_prompt_en, blueprint.biome)`.
        6.  **Preview & Confirmation**:
            *   Bot deletes status message.
            *   Send Photo (the generated image) with caption formatted using `blueprint` data (Name, Stats, Lore, Biome emoji). Use `FSInputFile` to send local files.
            *   Attach Inline Keyboard: "‚úÖ –ó–∞—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Ç–∞ –í–∏–¥–∞—Ç–∏" (Approve & Issue) or "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏".
        7.  **Finalize (On Button Click)**:
            *   Save `CardTemplate` to DB.
            *   Create `UserCard` for the target user instantly.
            *   Edit message: "üéâ –ö–∞—Ä—Ç–∫—É [Card Name] —Å—Ç–≤–æ—Ä–µ–Ω–æ —Ç–∞ –≤–∏–¥–∞–Ω–æ [User]!"
    *   The `escape_markdown()` function from `utils.text` should be used when sending the initial feedback message with the user's display name.
    *   **User Creation**: The `admin_autocard.py` handler automatically creates a User record if one doesn't exist when awarding a card.
    *   **Usage**:
        *   `/autocard` - Reply to a user's message (existing behavior)
        *   `/autocard @username` - Use username
        *   `/autocard 392817811` - Use userID
    *   Due to Telegram's 64-byte limit on callback data, store the blueprint data in Redis using the `SessionManager` and pass only the UUID in the callback.
    *   When handling the Approve & Issue or Cancel buttons:
        *   Check if the message is a photo (`callback.message.photo`).
        *   Use `edit_caption()` for photo messages.
        *   Use `edit_text()` for text messages.
        *   Ensure all user provided text is escaped using `escape_markdown()`.
*   Create `handlers/player.py` to handle player commands.
    *   Implement `/start` handler that:
        *   Gets or creates User record using pattern from `handlers/drops.py`.
        *   Responds with welcome message in Ukrainian.
        *   Logs the registration event.
        *   Sends main menu keyboard.
    *   Implement `/menu` handler that:
        *   Shows main menu keyboard.
    *   Implement `/me` or `/profile` handler that:
        *   Shows user profile with stats and inline keyboard.
    *   Implement `/inventory` handler that:
        *   Shows user's card collection with pagination and inline keyboard.
    *   Implement `/stats` handler that:
        *   Shows detailed statistics dashboard with inline keyboard.
    *   Implement `/help` handler that:
        *   Shows help/guide with inline keyboard.
    *   **`/start` Command**: The `/start` command is informational only and not strictly required for a user to receive cards. Card distribution handlers automatically create users if they don't exist. If `/start` should be mandatory, a check needs to be added to the card award functions.
    *   **Reply Keyboard**: Reply keyboards (persistent buttons at the bottom) only work in private chats with the bot, not in group chats. Test by messaging the bot privately.
        *   Appears after `/start` or `/menu`.
        *   Shows: üìä –ü—Ä–æ—Ñ—ñ–ª—å, üé¥ –ö–æ–ª–µ–∫—Ü—ñ—è, üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, ‚ùì –î–æ–ø–æ–º–æ–≥–∞.
    *   **Inline Keyboards**: Inline Keyboards (buttons below messages) work everywhere.
        *   Appear with `/profile`, `/inventory`, `/stats`, `/help`.
        *   Used for card details, pagination, and navigation.
    *   **User Registration**: User registration should be triggered on *any* interaction, not just specific commands like `/start`.
        *   **Implementation**: Modify the `get_or_create_user` function or equivalent to be called in a middleware that intercepts all messages.
        *   Now handled by `middlewares/user_registration.py`
    *   **Card Scrapping:**
        *   Implement `handle_scrap_card_request()` to show the scrapping confirmation message and reward amount.
        *   Implement `handle_scrap_card_confirm()` to delete the card and award scraps to the user.
        *   Implement `get_scrap_reward()` to calculate the scrap reward based on card rarity.
    *   **Main Menu Navigation**: Use inline keyboards for main menu navigation when editing messages.
        *   Implement `get_main_menu_inline_keyboard()` in `utils/keyboards.py` to return an `InlineKeyboardMarkup` with the main menu options.
        *   Update `handle_menu_navigation` in `handlers/player.py` to use `get_main_menu_inline_keyboard()`.
        *   Implement callback query handlers for all navigation actions ("profile", "inventory", "stats", "help").
    *   The inventory list and card detail view should display the card's `display_id`.
        *   Inventory list: `üÜî POM-A1B2 | ‚öîÔ∏è {stats.get('atk', 0)} / üõ°Ô∏è {stats.get('def', 0)}`
        *   Card detail view: `üÜî **ID:** {user_card.display_id}`
*   Create `handlers/inline.py` to handle inline queries for player interactions (trading, battles, etc.).
    *   `handle_inline_query()` - main menu on `@botname` call:
        *   Trading
        *   Duel challenge
        *   Profile view
        *   Card collection
    *   Card search by name.
    *   `handle_chosen_inline_result()` - placeholder for session management.
*   Extract trading logic into separate handler file: `handlers/trading.py`
    *   All trade-related callback handlers
    *   Trade execution logic with atomic transactions
    *   Validation (card ownership, session expiry)
*   Create `handlers/battles.py` with full battle flow: challenge, accept, stake, deck selection, battle execution
*   Command hints (descriptions) are implemented for all bot commands using Telegram's `setMyCommands` API.
    *   Regular users see only player commands.
    *   Admin users see both player and admin commands.
    *   Commands are set at bot startup and dynamically when admin users interact.
*   Add a new admin command `/createcommoncard` that creates reusable card templates using AI generation from a detailed prompt.
    *   The AI should understand it's creating a common/meme card (like "–®–ª—é—Ö–æ–±–æ—Ç")
    *   Support ALL rarities (Common, Rare, Epic, Legendary, Mythic) - AI should choose appropriate rarity based on prompt, or admin can specify
    *   The AI should understand it's creating a reusable template card (not user-specific)
    *   For meme cards like "–®–ª—é—Ö–æ–±–æ—Ç", AI should typically choose Common or Rare rarity unless specified otherwise
    *   **Usage**: `/createcommoncard <detailed prompt>` (optionally with rarity hint)
        *   Example: `/createcommoncard –®–ª—é—Ö–æ–±–æ—Ç - –≤—É–ª—å–≥–∞—Ä–Ω–∏–π –º–µ–º–Ω–∏–π —Ä–æ–±–æ—Ç –∑ —Ç–µ—Ö–Ω–æ –±—ñ–æ–º—É, –Ω–∏–∑—å–∫–∞ —Ä—ñ–¥–∫—ñ—Å—Ç—å`
    *   The AI architect service already supports all rarities in its system prompt
*   Implement the admin command `/test_normals` to send all NORMAL card templates as a test.
    *   Admin-only: checks admin status before executing.
    *   Sends all NORMAL cards: Common, Rare, Epic, Legendary, Mythic.
    *   Uses animated versions when available: Epic, Legendary, Mythic use `*_animated.gif` if present.
    *   Sends as photos or GIFs: displays normal cards as photos, and animated ones as GIFs.
    *   Rate limiting: 0.5s delay between sends to avoid Telegram rate limits.
    *   Status messages: shows progress and final count.
    *   **Usage**: `/test_normals`
    *   **What it does**: Finds all NORMAL card templates in `assets/placeholders/`, prioritizes animated versions for Epic, Legendary, Mythic, sends each card as a document with a caption showing rarity, and reports how many cards were sent.
*   Create animated WebP files for rarer cards with holographic/glowing effects.
*   **Getting Group Chat Icon**:
    *   Use `bot.get_chat(chat_id)` to get chat object.
    *   Access the `photo` field of the chat object.
    *   Use `bot.get_file()` and `bot.download_file()` to download the image.
*   **Getting User Profile Picture**:
    *   Use `bot.get_user_profile_photos(user_id=user_id, limit=1)` to get the most recent profile picture.
    *   Use `bot.get_file()` and `bot.download_file()` to download the image.
    *   This works even if the user isn't registered, as long as the bot has access to them and they have a profile picture set.
*   Cards are sent as photos via `answer_photo`, not stickers.
*   Cards are sent as photos via `answer_photo`, not stickers. To make them appear larger, we can:
    1.  Use `answer_document` instead of `answer_photo` (shows larger)
    2.  Ensure images are sent at full resolution
*   Cards are sent as photos via `answer_photo`, not stickers. To make them appear larger, we can:
    1.  Use `answer_document` instead of `answer_photo` (shows larger)
    2.  Ensure images are sent at full resolution
*   Updating the code to send cards larger. For rarer cards (Epic, Legendary, Mythic), sending as documents (larger display) and using animated versions when available:
*   Updating the code to send cards larger. For rarer cards (Epic, Legendary, Mythic), sending as documents (larger display) and using animated versions when available:
*   Updating the code to send all cards (including Common and Rare) as documents so they display larger:
*   Updating the code so all cards (Common, Rare, Epic, Legendary, Mythic) are sent as documents, which displays them larger in Telegram chats.

## DATABASE

*   Use `database/session.py` for database session management.
*   Use `AsyncSession` from SQLAlchemy for asynchronous database operations.
*   Implement `get_session` dependency function to get database session.
*   Modify `database/models.py` to add message logging.
    *   **New Model `MessageLog`**:
        *   `id` (BigInt, PK, auto-increment)
        *   `user_id` (BigInt, FK to User.telegram_id, indexed)
        *   `chat_id` (BigInt, FK to GroupChat.chat_id)
        *   `content` (Text, store truncated message text up to 500 chars)
        *   `created_at` (DateTime, default now, indexed)
            *   Use `insert_default=lambda: datetime.now(timezone.utc)` instead of `default_factory` for non-dataclass SQLAlchemy models.
            *   Must define `DateTime(timezone=True)` as the first argument to `mapped_column` to ensure timezone awareness.
    *   **`UserCard.acquired_at`**:
        *   Use `insert_default=lambda: datetime.now(timezone.utc)` instead of `default_factory` for non-dataclass SQLAlchemy models.
        *   Must define `DateTime(timezone=True)` as the first argument to `mapped_column` to ensure timezone awareness.
        *   Must define `DateTime(timezone=True)` as the first argument to `mapped_column` to ensure timezone awareness.
    *   **`UserCard.display_id`**:
        *   `display_id`: Short human-readable unique ID (e.g., "POM-A1B2"). String(10), nullable=False, unique=True, index=True.

## SCHEDULER

*   Implement `services/scheduler.py` using `apscheduler`.
    *   Create `DropScheduler` class using APScheduler's `AsyncIOScheduler`.
    *   Job `trigger_random_drops` runs every X minutes (default: 10, configurable).
    *   Fetches active groups from the database.
    *   For each group (or a