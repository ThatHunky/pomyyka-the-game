---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## PROJECT RULES

*   Project name: Хроніки Помийки (Chronicles of the Dumpster) - A Ukrainian Telegram Card Game Bot.
*   Target Locale: Ukrainian ("uk")

## TECH STACK

*   Python: 3.14
*   aiogram: 3.x
*   SQLAlchemy: Async
*   PostgreSQL: 17-alpine
*   Redis: alpine
*   Docker Compose
*   pydantic-settings
*   asyncpg
*   alembic
*   apscheduler
*   google-genai

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   `.env.example`: Contains example environment variables: `BOT_TOKEN` (required), `DB_URL` (required), `REDIS_URL` (required), `GEMINI_API_KEY` (optional, bot can run without it), `LOCALE` (defaults to "uk").

## CODING STANDARDS

*   Use `pydantic-settings` for configuration management.
*   Output logs in JSON format using `structlog`.
*   The application must be runnable without the Gemini API key being present (manual adding is acceptable). When `GEMINI_API_KEY` is not provided, Gemini-related functionality should be gracefully disabled.
*   When tracking group chats in `middlewares/group_tracker.py`, use PostgreSQL's `INSERT ON CONFLICT DO NOTHING` to prevent errors when the bot joins a group it has already been in.
*   All Admin prompts should be in Ukrainian.

## WORKFLOW & RELEASE RULES

## DEBUGGING

## INFRASTRUCTURE

*   Docker Compose should define `bot`, `db` (PostgreSQL), and `redis` services.
*   Docker container must wait for Postgres and Redis to be healthy before starting the bot. This can be achieved through health checks in `docker-compose.yml` and/or retry logic in the Python startup code.
*   Use named volumes for `pg_data` and `redis_data` to persist data.

## REDIS

*   Utilize `services/redis_lock.py` with a Lua script for atomic operations to prevent race conditions when claiming drops. The Lua script should:
    *   Atomically check if the drop key exists.
    *   If it doesn't, set the key to the user ID, set a TTL, and return 1.
    *   If it does exist, return 0.
*   Use async Redis (`redis.asyncio`) to match the project's async pattern.
*   Load the script once and cache it via SHA.
*   Implement error handling: return `False` on Redis errors to prevent double claims.
*   Implement `DropManager` class in `services/redis_lock.py` with methods:
    *   `try_claim_drop(message_id, user_id, ttl)`
    *   `release_drop()` - manual cleanup
    *   `get_claim_owner()` - check who claimed a drop
    *   `close()` - cleanup connection

## MIDDLEWARE

*   Implement `middlewares/group_tracker.py` to track group chats.
*   Create `ChatTrackingMiddleware` that intercepts every update.
*   If `chat.type` is `supergroup` or `group`:
    *   Upsert the `GroupChat` table (INSERT ON CONFLICT DO NOTHING). This ensures we have a list of all groups the bot is in.

## HANDLERS

*   Create `handlers/drops.py` to handle drop claims.
*   Implement a Callback Query Handler for data `claim_drop`.
*   Call `DropManager.try_claim_drop(message.message_id, user.id)`.
    *   **If Success**:
        *   Award card to user in DB.
        *   Edit message text: "✅ **[User]** блискавично схопив [Card Name]!" (Use Ukrainian).
    *   **If Fail**:
        *   Answer callback query with alert: "❌ Хтось виявився спритнішим!" (Alert/Toast).
*   Create `handlers/admin.py` to handle admin commands.
*   Implement Admin Card Creation Flow in `handlers/admin.py`.
    *   **FSM**: States `WaitingForName`, `WaitingForArtPrompt`, `WaitingForStats`.
    *   `/newcard` -> Input Name.
    *   Select Biome (Inline Keyboard of Biomes).
    *   Input Prompt -> Gen Art -> Review.
    *   Input Stats -> Save.
    *   **Nano Banana Integration**:
        *   Use `google-genai` to generate art.
        *   Prompt: "Trading card art, [User Prompt], style of [Biome Style]".

## DATABASE

*   Use `database/session.py` for database session management.
*   Use `AsyncSession` from SQLAlchemy for asynchronous database operations.
*   Implement `get_session` dependency function to get database session.

## SCHEDULER

*   Implement `services/scheduler.py` using `apscheduler`.
    *   Create `DropScheduler` class using APScheduler's `AsyncIOScheduler`.
    *   Job `trigger_random_drops` runs every X minutes (default: 10, configurable).
    *   Fetches active groups from the database.
    *   For each group (or a random subset):
        *   Roll RNG with configurable chance (default: 5%).
        *   On success:
            *   Calculates biome using `get_chat_biome(chat_id)`.
            *   Selects a random `CardTemplate` where `biome_affinity == biome`.
            *   Sends a message with the specified text and an inline "✋ Хапнути" button.
            *   Uses `ClaimDropCallback` with the template ID.
*   Scheduler is configured with:
    *   Interval: 10 minutes (configurable via constructor).
    *   Drop chance: 5% per group (configurable via constructor).
    *   Optional max groups per run limit.
*   The scheduler starts automatically when the bot starts and stops gracefully on shutdown.
*   Integration: Start the scheduler in `main.py` on startup.

## MAIN APPLICATION

*   Create `main.py` as application entry point that:
    *   Initializes logging and database.
    *   Creates Bot and Dispatcher instances.
    *   Registers routers (drops router, admin router).
    *   Initializes and starts the scheduler on startup.
    *   Handles cleanup on shutdown.