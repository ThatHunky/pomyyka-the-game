---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## PROJECT RULES

*   Project name: –•—Ä–æ–Ω—ñ–∫–∏ –ü–æ–º–∏–π–∫–∏ (Chronicles of the Dumpster) - A Ukrainian Telegram Card Game Bot.
*   Target Locale: Ukrainian ("uk")

## TECH STACK

*   Python: 3.14
*   aiogram: 3.x -> 3.17 (>=3.17,<4.0)
*   SQLAlchemy: Async
*   PostgreSQL: 17-alpine
*   Redis: alpine
*   Docker Compose
*   pydantic-settings
*   asyncpg
*   alembic
*   apscheduler
*   google-genai: >=1.0.0 -> 1.56.0 (Strict versioning)
*   pydantic: >=2.10 (>=2.10,<3.0)
*   redis: ^5.2.0 (>=5.2.0,<6.0)

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   `.env.example`: Contains example environment variables: `BOT_TOKEN` (required), `DB_URL` (required), `REDIS_URL` (required), `GEMINI_API_KEY` (optional, bot can run without it), `LOCALE` (defaults to "uk"), `ADMIN_USER_IDS` (comma-separated list of Telegram user IDs, for admin authentication).
*   Context: Using the "Gemini 3.0" feature set which requires the 1.56 SDK.
*   Game Design Document (GDD): `plan-doc.md` - a complete map of mechanics, economics, and logic, which combines already written code with new ideas (trading, currency, battles).
*   Chat Export Format: Telegram JSON export (result.json from Telegram Desktop).
*   Chat Export Location: `data/chat_exports/` directory. Place `result.json` files from Telegram Desktop exports there.
*   To make the `data/chat_exports` folder accessible from the container, add a volume mount in `docker-compose.yml` to mount the directory on the host to `/app/data/chat_exports` inside the container:
    ```yaml
    volumes:
      - ./data/chat_exports:/app/data/chat_exports
    ```
    *   The `data/chat_exports` directory on the host is mounted into the container at `/app/data/chat_exports/`. Place JSON files in `data/chat_exports/` on your host machine, and they are automatically accessible inside the container at `/app/data/chat_exports/`. No need to copy files into the container or rebuild images.
*   The contents of the chat export folder (specifically *.json and *.txt files) must be added to `.gitignore`.

## CODING STANDARDS

*   Use `pydantic-settings` for configuration management.
*   Output logs in JSON format using `structlog`.
*   The application must be runnable without the Gemini API key being present (manual adding is acceptable). When `GEMINI_API_KEY` is not provided, Gemini-related functionality should be gracefully disabled.
*   When tracking group chats in `middlewares/group_tracker.py`, use PostgreSQL's `INSERT ON CONFLICT DO NOTHING` to prevent errors when the bot joins a group it has already been in.
*   All Admin prompts should be in Ukrainian.
*   Escape special Markdown V2 characters in user-provided content (card names, usernames, rarity/biome values, user first names) to prevent parsing errors. Use `utils/text.py` with `escape_markdown()`.
*   The bot should primarily edit messages instead of sending new ones to reduce spam. Callback handlers should only edit existing messages, never send new ones.
*   When parsing `ADMIN_USER_IDS` from the environment variables, the validator in `config.py` must handle:
    *   Quoted values (`"392817811"` or `'392817811'`)
    *   Extra whitespace
    *   Invalid entries (log a warning instead of failing)
    *   Single `int` values (e.g., `392817811`)
*   Admin access must be available via username or userID.
*   When using `CallbackData.pack()`, be aware that it uses colons (`:`) as field separators. To avoid `ValueError: Separator symbol ':' can not be used in value` due to Telegram's 64-byte limit on callback data, store the relevant data in Redis using the `SessionManager` and pass only the UUID in the callback.

## WORKFLOW & RELEASE RULES

*   Bot should primarily edit messages instead of sending new ones to reduce spam.
*   If running the bot in Docker, restart the container after changing environment variables for the changes to take effect. Use `docker-compose restart bot` or `docker-compose up -d --build bot`.

## DEBUGGING

*   `EditMessageText` expects `InlineKeyboardMarkup`, but a `ReplyKeyboardMarkup` is being passed. Editing messages only supports inline keyboards. Ensure that `safe_edit_text()` and Telegram's `edit_text()` are called with `InlineKeyboardMarkup` when editing messages.
*   When debugging admin command access, check the following:
    *   The `.env` file format should be `ADMIN_USER_IDS=392817811` (no quotes, no spaces around the `=`).
    *   Check the logs at startup to verify what admin IDs were loaded.
    *   When attempting the command, check the logs to see what user ID is being checked and what admin IDs are configured.
*   If the callback data exceeds Telegram's 64-byte limit, store the data in Redis using the `SessionManager` and pass only the UUID in the callback.
*   When editing the photo message caption in `handlers/admin_autocard.py` with `edit_text`, ensure that the `chat_id` and `message_id` are correctly passed and that the caption is properly formatted and escaped. The handlers `handle_autocard_cancel` and `handle_autocard_approve` should be reviewed for potential issues.

## INFRASTRUCTURE

*   Docker Compose should define `bot`, `db` (PostgreSQL), and `redis` services.
*   Docker container must wait for Postgres and Redis to be healthy before starting the bot. This can be achieved through health checks in `docker-compose.yml` and/or retry logic in the Python startup code.
*   Use named volumes for `pg_data` and `redis_data` to persist data.
*   Dockerfile: The `CMD` instruction should be `CMD ["python", "main.py"]` to correctly start the bot application.
*   To make the `data/chat_exports` folder accessible from the container, add a volume mount in `docker-compose.yml` to mount the directory on the host to `/app/data/chat_exports` inside the container:
    ```yaml
    volumes:
      - ./data/chat_exports:/app/data/chat_exports
    ```
    *   The `data/chat_exports` directory on the host is mounted into the container at `/app/data/chat_exports/`. Place JSON files in `data/chat_exports/` on your host machine, and they are automatically accessible inside the container at `/app/data/chat_exports/`. No need to copy files into the container or rebuild images.

## REDIS

*   Utilize `services/redis_lock.py` with a Lua script for atomic operations to prevent race conditions when claiming drops. The Lua script should:
    *   Atomically check if the drop key exists.
    *   If it doesn't, set the key to the user ID, set a TTL, and return 1.
    *   If it does exist, return 0.
*   Use async Redis (`redis.asyncio`) to match the project's async pattern.
*   Load the script once and cache it via SHA.
*   Implement error handling: return `False` on Redis errors to prevent double claims.
*   Implement `DropManager` class in `services/redis_lock.py` with methods:
    *   `try_claim_drop(message_id, user_id, ttl)`
    *   `release_drop()` - manual cleanup
    *   `get_claim_owner()` - check who claimed a drop
    *   `close()` - cleanup connection
*   Implement `services/session_manager.py` to manage trade and battle sessions.
*   The `SessionManager` should also include methods for storing and retrieving blueprint data for autocard flows, using UUIDs as keys. These methods are:
    *   `store_blueprint(blueprint_data: dict, ttl: int = 3600) -> str`: Stores blueprint data in Redis for autocard callbacks.
    *   `get_blueprint(blueprint_id: str) -> Optional[dict]`: Gets blueprint data from Redis.
    *   `delete_blueprint(blueprint_id: str) -> bool`: Deletes blueprint data from Redis.

## MIDDLEWARE

*   Implement `middlewares/group_tracker.py` to track group chats.
*   Create `ChatTrackingMiddleware` that intercepts every update.
*   If `chat.type` is `supergroup` or `group`:
    *   Upsert the `GroupChat` table (INSERT ON CONFLICT DO NOTHING). This ensures we have a list of all groups the bot is in.
*   Implement `middlewares/logger.py` to log messages in group chats.
    *   Create a new middleware that runs after `GroupTrackingMiddleware`.
    *   **Logic**: For every text message in a group chat:
        *   Fire-and-forget an async task to insert the message into `MessageLog`.
    *   **Optimization**: Do *not* log commands (starting with `/`).
*   **Middleware Event Handling**: When registering middlewares using `dp.message.middleware()`, the `event` parameter is a `Message` object, not an `Update` object.
*   User registration should be triggered on *any* interaction, not just specific commands like `/start`.
    *   **Implementation**: Modify the `get_or_create_user` function or equivalent to be called in a middleware that intercepts all messages.
    *   Implement `middlewares/user_registration.py` to automatically register users on any interaction (messages, callback queries, etc.).
    *   Register the middleware for both `message` and `callback_query` events.
    *   Uses PostgreSQL `ON CONFLICT DO NOTHING` for thread-safe registration.
    *   After user registration, check if user is admin. If admin, set their commands to include admin commands using `Bot.set_my_commands()`, `BotCommandScopeChat(chat_id=user_id)`, and `get_all_commands()`.

## HANDLERS

*   Create `handlers/drops.py` to handle drop claims.
    *   **Import Fix**: Use `from aiogram.filters.callback_data import CallbackData` instead of `from aiogram.filters import CallbackData`.
        *   **Note**: All handler files (`handlers/drops.py`, `handlers/admin.py`, `handlers/admin_autocard.py`) already use the correct import path: `from aiogram.filters.callback_data import CallbackData`.
    *   **Loop Fix**: In `_award_card_and_update_message`, remove the `finally:` block and move the `break` statement to the end of the `try` block.
    *   **Python 3.14 Safety**: Remove the `finally:` block containing `break`. Instead, place the `break` statement as the last line inside the `try` block.
    *   **User Creation**: When a user claims a drop, the `_award_card_and_update_message` function automatically creates a User record if one doesn't exist.
*   Create `handlers/admin.py` to handle admin commands.
    *   **Import Fix**: Use `from aiogram.filters.callback_data import CallbackData` instead of `from aiogram.filters import CallbackData`.
    *   **Python 3.14 Safety**: Remove the `finally:` block containing `break`. Rely on `get_session()`'s natural termination if it yields only once.
    *   `/import_chat <filename>` - Import chat history from Telegram JSON export.
    *   **Usage**:
        1.  Place the `result.json` file in `data/chat_exports/`
        2.  Run `/import_chat result.json` in the bot.
*   Implement a Callback Query Handler for data `claim_drop`.
*   Call `DropManager.try_claim_drop(message.message_id, user.id)`.
    *   **If Success**:
        *   Award card to user in DB.
        *   Edit message text: "‚úÖ **[User]** –±–ª–∏—Å–∫–∞–≤–∏—á–Ω–æ —Å—Ö–æ–ø–∏–≤ [Card Name]!" (Use Ukrainian).
    *   **If Fail**:
        *   Answer callback query with alert: "‚ùå –•—Ç–æ—Å—å –≤–∏—è–≤–∏–≤—Å—è —Å–ø—Ä–∏—Ç–Ω—ñ—à–∏–º!" (Alert/Toast).
*   Implement Admin Card Creation Flow in `handlers/admin.py`.
    *   **FSM**: States `WaitingForName`, `WaitingForArtPrompt`, `WaitingForStats`.
    *   `/newcard` -> Input Name.
    *   Select Biome (Inline Keyboard of Biomes).
    *   Input Prompt -> Gen Art -> Review.
    *   Input Stats -> Save.
    *   **Nano Banana Integration**:
        *   Use `NanoBananaService` to generate art.
        *   Prompt: "Trading card art, [User Prompt], style of [Biome Style]".
        *   The `generate_card_image()` function in `handlers/admin.py` generates card image using Nano Banana Pro (Gemini 3 Pro Image).
        *   To complete the image generation, implement the actual API call in `generate_card_image()` based on your image generation service (Nano Banana or another service). The function should return a relative filepath to saved image.
        *   The flow continues even if image generation fails (image_url can be None), allowing cards to be created without images if needed.
*   Implement `handlers/admin_autocard.py`.
    *   Command: `/autocard`
    *   Supports three modes:
        *   Reply mode: `/autocard` (reply to a message)
        *   Username mode: `/autocard @username`
        *   UserID mode: `/autocard 392817811`
    *   **Logic Flow (Async):**
        1.  **Trigger**: Admin replies `/autocard` to a user message, or uses `/autocard @username` or `/autocard userID`.
        2.  **Feedback**: Bot sends "üïµÔ∏è‚Äç‚ôÇÔ∏è –ê–Ω–∞–ª—ñ–∑—É—é –æ—Å–æ–±–∏—Å—Ç—ñ—Å—Ç—å [User]..." (Analyzing personality...).
        3.  **Fetch Context**:
            *   DB Query: Select last 50 messages from `MessageLog` for this `target_user_id`.
            *   Flatten into a list of strings.
        4.  **Architect Step**:
            *   Bot edits message: "üß† –ü—Ä–æ—î–∫—Ç—É—é –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä—É –∫–∞—Ä—Ç–∫–∏..." (Designing card architecture...).
            *   Call `CardArchitectService.generate_blueprint(logs, target_user_id, target_user_name)`. Pass the `target_user_id` and `target_user_name` to the service.
        5.  **Art Forge Step**:
            *   Bot edits message: "üé® –ö—É—é –≤—ñ–∑—É–∞–ª —É –Ω–∞–Ω–æ-–≥–æ—Ä–Ω—ñ..." (Forging visuals in –Ω–∞–Ω–æ-–≥–æ—Ä–Ω—ñ...).
            *   Call `ArtForgeService.forge_card_image(blueprint.raw_image_prompt_en, blueprint.biome)`.
        6.  **Preview & Confirmation**:
            *   Bot deletes status message.
            *   Send Photo (the generated image) with caption formatted using `blueprint` data (Name, Stats, Lore, Biome emoji). Use `FSInputFile` to send local files.
            *   Attach Inline Keyboard: "‚úÖ –ó–∞—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Ç–∞ –í–∏–¥–∞—Ç–∏" (Approve & Issue) or "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏".
        7.  **Finalize (On Button Click)**:
            *   Save `CardTemplate` to DB.
            *   Create `UserCard` for the target user instantly.
            *   Edit message: "üéâ –ö–∞—Ä—Ç–∫—É [Card Name] —Å—Ç–≤–æ—Ä–µ–Ω–æ —Ç–∞ –≤–∏–¥–∞–Ω–æ [User]!"
    *   The `escape_markdown()` function from `utils.text` should be used when sending the initial feedback message with the user's display name.
    *   **User Creation**: The `admin_autocard.py` handler automatically creates a User record if one doesn't exist when awarding a card.
    *   **Usage**:
        *   `/autocard` - Reply to a user's message (existing behavior)
        *   `/autocard @username` - Use username
        *   `/autocard 392817811` - Use userID
    *   Due to Telegram's 64-byte limit on callback data, store the blueprint data in Redis using the `SessionManager` and pass only the UUID in the callback.
*   Create `handlers/player.py` to handle player commands.
    *   Implement `/start` handler that:
        *   Gets or creates User record using pattern from `handlers/drops.py`.
        *   Responds with welcome message in Ukrainian.
        *   Logs the registration event.
        *   Sends main menu keyboard.
    *   Implement `/menu` handler that:
        *   Shows main menu keyboard.
    *   Implement `/me` or `/profile` handler that:
        *   Shows user profile with stats and inline keyboard.
    *   Implement `/inventory` handler that:
        *   Shows user's card collection with pagination and inline keyboard.
    *   Implement `/stats` handler that:
        *   Shows detailed statistics dashboard with inline keyboard.
    *   Implement `/help` handler that:
        *   Shows help/guide with inline keyboard.
    *   **`/start` Command**: The `/start` command is informational only and not strictly required for a user to receive cards. Card distribution handlers automatically create users if they don't exist. If `/start` should be mandatory, a check needs to be added to the card award functions.
    *   **Reply Keyboard**: Reply keyboards (persistent buttons at the bottom) only work in private chats with the bot, not in group chats. Test by messaging the bot privately.
        *   Appears after `/start` or `/menu`.
        *   Shows: üìä –ü—Ä–æ—Ñ—ñ–ª—å, üé¥ –ö–æ–ª–µ–∫—Ü—ñ—è, üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, ‚ùì –î–æ–ø–æ–º–æ–≥–∞.
    *   **Inline Keyboards**: Inline Keyboards (buttons below messages) work everywhere.
        *   Appear with `/profile`, `/inventory`, `/stats`, `/help`.
        *   Used for card details, pagination, and navigation.
    *   **User Registration**: User registration should be triggered on *any* interaction, not just specific commands like `/start`.
        *   **Implementation**: Modify the `get_or_create_user` function or equivalent to be called in a middleware that intercepts all messages.
        *   Now handled by `middlewares/user_registration.py`
    *   **Card Scrapping:**
        *   Implement `handle_scrap_card_request()` to show the scrapping confirmation message and reward amount.
        *   Implement `handle_scrap_card_confirm()` to delete the card and award scraps to the user.
        *   Implement `get_scrap_reward()` to calculate the scrap reward based on card rarity.
    *   **Main Menu Navigation**: Use inline keyboards for main menu navigation when editing messages.
        *   Implement `get_main_menu_inline_keyboard()` in `utils/keyboards.py` to return an `InlineKeyboardMarkup` with the main menu options.
        *   Update `handle_menu_navigation` in `handlers/player.py` to use `get_main_menu_inline_keyboard()`.
        *   Implement callback query handlers for all navigation actions ("profile", "inventory", "stats", "help").
*   Create `handlers/inline.py` to handle inline queries for player interactions (trading, battles, etc.).
    *   `handle_inline_query()` - main menu on `@botname` call:
        *   Trading
        *   Duel challenge
        *   Profile view
        *   Card collection
    *   Card search by name.
    *   `handle_chosen_inline_result()` - placeholder for session management.
*   Extract trading logic into separate handler file: `handlers/trading.py`
    *   All trade-related callback handlers
    *   Trade execution logic with atomic transactions
    *   Validation (card ownership, session expiry)
*   Create `handlers/battles.py` with full battle flow: challenge, accept, stake, deck selection, battle execution
*   Command hints (descriptions) are implemented for all bot commands using Telegram's `setMyCommands` API.
    *   Regular users see only player commands.
    *   Admin users see both player and admin commands.
    *   Commands are set at bot startup and dynamically when admin users interact.
*   Add a new admin command `/createcommoncard` that creates reusable card templates using AI generation from a detailed prompt.
    *   The AI should understand it's creating a common/meme card (like "–®–ª—é—Ö–æ–±–æ—Ç")
    *   Support ALL rarities (Common, Rare, Epic, Legendary, Mythic) - AI should choose appropriate rarity based on prompt, or admin can specify
    *   The AI should understand it's creating a reusable template card (not user-specific)
    *   For meme cards like "–®–ª—é—Ö–æ–±–æ—Ç", AI should typically choose Common or Rare rarity unless specified otherwise
    *   **Usage**: `/createcommoncard <detailed prompt>` (optionally with rarity hint)
        *   Example: `/createcommoncard –®–ª—é—Ö–æ–±–æ—Ç - –≤—É–ª—å–≥–∞—Ä–Ω–∏–π –º–µ–º–Ω–∏–π —Ä–æ–±–æ—Ç –∑ —Ç–µ—Ö–Ω–æ –±—ñ–æ–º—É, –Ω–∏–∑—å–∫–∞ —Ä—ñ–¥–∫—ñ—Å—Ç—å`
    *   The AI architect service already supports all rarities in its system prompt

## DATABASE

*   Use `database/session.py` for database session management.
*   Use `AsyncSession` from SQLAlchemy for asynchronous database operations.
*   Implement `get_session` dependency function to get database session.
*   Modify `database/models.py` to add message logging.
    *   **New Model `MessageLog`**:
        *   `id` (BigInt, PK, auto-increment)
        *   `user_id` (BigInt, FK to User.telegram_id, indexed)
        *   `chat_id` (BigInt, FK to GroupChat.chat_id)
        *   `content` (Text, store truncated message text up to 500 chars)
        *   `created_at` (DateTime, default now, indexed)
            *   Use `insert_default=lambda: datetime.now(timezone.utc)` instead of `default_factory` for non-dataclass SQLAlchemy models.
            *   Must define `DateTime(timezone=True)` as the first argument to `mapped_column` to ensure timezone awareness.
    *   **`UserCard.acquired_at`**:
        *   Use `insert_default=lambda: datetime.now(timezone.utc)` instead of `default_factory` for non-dataclass SQLAlchemy models.
        *   Must define `DateTime(timezone=True)` as the first argument to `mapped_column` to ensure timezone awareness.

## SCHEDULER

*   Implement `services/scheduler.py` using `apscheduler`.
    *   Create `DropScheduler` class using APScheduler's `AsyncIOScheduler`.
    *   Job `trigger_random_drops` runs every X minutes (default: 10, configurable).
    *   Fetches active groups from the database.
    *   For each group (or a random subset):
        *   Roll RNG with configurable chance (default: 5%).
        *   On success:
            *   Calculates biome using `get_chat_biome(chat_id)`.
            *   Selects a random `CardTemplate` where `biome_affinity == biome`.
            *   Sends a message with the specified text and an inline "‚úã –•–∞–ø–Ω—É—Ç–∏" button.
            *   Uses `ClaimDropCallback` with the template ID.
*   Scheduler is configured with:
    *   Interval: 10 minutes (configurable via constructor).
    *   Drop chance: 5% per group (configurable via constructor).
    *   Optional max groups per run limit.
*   The scheduler starts automatically when the bot starts and stops gracefully on shutdown.
*   Integration: Start the scheduler in `main.py` on startup.
*   Create `services/cleanup.py` with daily cleanup job.
    *   **Logic**: `DELETE FROM message_logs WHERE created_at < now() - INTERVAL '7 days'`.
    *   This keeps the database lean, only keeping recent context for generation.
    *   **Python 3.14 Safety**: Remove the `finally:` block containing `break`. Rely on `get_session()`s natural termination if it yields only once.

## MAIN APPLICATION

*   Create `main.py` as application entry point that:
    *   Initializes logging and database.
    *   Creates Bot and Dispatcher instances.
    *   Registers routers (drops router, admin router, admin_autocard router, player router, inline router).
    *   Registers middlewares (ChatTrackingMiddleware, MessageLoggingMiddleware) - order matters.
    *   Initializes and starts the scheduler on startup.
    *   Handles cleanup on shutdown.
    *   Update `main.py` to register middleware and start cleanup scheduler.
    *   Ensure the startup sequence wraps the `await bot.delete_webhook()` call in a try/except block. If the bot was previously running on a webhook, this can crash the polling startup.
    *   Log admin configuration at startup: Log the number of admins configured and whether admin functionality is enabled.
    *   Register `UserRegistrationMiddleware` for both `message` and `callback_query` events to ensure users are automatically registered on any interaction.
    *   Implements command hints (descriptions) for all bot commands.
        *   Regular users will see hints for player commands only.
        *   Admins will see hints for both player and admin commands.
        *   Uses `utils/commands.py` to centralize command definitions
        *   Uses `Bot.set_my_commands()` from aiogram for setting commands
        *   Uses `BotCommandScopeDefault()` for default (all users) scope
        *   Uses `BotCommandScopeChat(chat_id=user_id)` for per-user scope
        *   Sets admin commands asynchronously after bot initialization
        *   Handles errors gracefully (log but don't fail startup)

## AI SERVICES

*   Create `services/ai_architect.py`.
    *   Stack: `google-genai`, `pydantic`.
    *   **Define Pydantic Model (`CardBlueprint`)**:
        *   `target_user_id`: int
        *   `card_name_ua`: str
        *   `rarity`: Rarity Enum (Common, Rare, etc.)
        *   `biome`: BiomeType Enum (Techno, Fire, etc.)
        *   `stats_atk`: int (0-100)
        *   `stats_def`: int (0-100)
        *   `stats_meme`: int (0-100)
        *   `lore_ua`: str (2 sentences max)
        *   `raw_image_prompt_en`: str (Descriptive prompt for visual elements only)
    *   **Class `CardArchitectService`**:
        *   Init with `GEMINI_API_KEY`.
        *   Method `generate_blueprint(user_context_logs: list[str], target_user_id: Optional[int] = None, user_name: Optional[str] = None) -> CardBlueprint`:
            *   **System Instruction**: Convert the "Gemini Gem" prompt provided earlier into a Python string. Crucially, emphasize the output must be valid JSON matching the `CardBlueprint` schema.
            *   **Call Gemini**: Use `gemini-3-flash-preview` with `client.models.generate_content` and `generation_config={"response_mime_type": "application/json"}`. Sticking to the default thinking level (which is usually "Dynamic" for Flash 3) is safer for now to avoid 400 Bad Request errors.
            *   **Note**: Using default thinking level for Gemini 3 Flash (usually "Dynamic") to avoid 400 Bad Request errors until SDK fully supports explicit `thinking_config`.
            *   **Parsing**: Use `CardBlueprint.model_validate_json(response.text)` to ensure robust parsing.
            *   **Error Handling**: Catch validation errors and retry once if Gemini hallucinates the schema.
            *   ```python
                            response = self._client.models.generate_content(
                                model=self._model_id,
                                contents=user_message,
                                config=types.GenerateContentConfig(
                                    system_instruction=self._system_instruction,
                                    # Native Pydantic support in v1.56+
                                    response_schema=CardBlueprint,
                                    response_mime_type="application/json",
                                    # Enable Gemini 3.0 "Thinking" (Reasoning)
                                    # "medium" offers the best balance for a game (smarter than low, faster than high)
                                    thinking_config=types.ThinkingConfig(
                                        include_thoughts=False,
                                        include_thoughts=False,
                                        thinking_level="medium"
                                    ),
                                    temperature=1.0,
                                )
                            )

                            if not response.parsed:
                                raise ValueError("Gemini 3 failed to return a valid blueprint.")

                            blueprint = response.parsed
            ```
*   Create `services/art_forge.py`.
    *   Stack: `google-genai` (for Gemini 3 Pro Image).
    *   **Style Constants**:
        *   Define a constant string `UNIFORM_STYLE_GUIDE`: "Trading card illustration, cohesive high fantasy cyberpunk fusion art style, ornate border design elements, digital painting, masterpiece, highly detailed, 8k resolution, cinematic lighting, rich textures."
    *   **Class `ArtForgeService`**:
        *   Init with `GEMINI_API_KEY` and store pass for `media/cards/` directory.
        *   Method `forge_card_image(blueprint_prompt: str, biome: BiomeType) -> str (filepath)`:
            *   **Combine Prompt**: f"{UNIFORM_STYLE_GUIDE}. Subject: {blueprint_prompt}. Biome theme: {biome.value}."
            *   **Call API**: Use the Gemini Image Generation model (`gemini-3-pro-image-preview`) and `client.models.generate_content` with `config=types.GenerateContentConfig(imageConfig=types.ImageConfig(aspectRatio="3:4",imageSize="2K",),safety_settings=[types.SafetySetting(category="HARM_CATEGORY_HATE_SPEECH",threshold="BLOCK_ONLY_HIGH"),types.SafetySetting(category="HARM_CATEGORY_HARASSMENT",threshold="BLOCK_ONLY_HIGH"),types.SafetySetting(category="HARM_CATEGORY_SEXUALLY_EXPLICIT",threshold="BLOCK_ONLY_HIGH"),types.SafetySetting(category="HARM_CATEGORY_DANGEROUS_CONTENT",threshold="BLOCK_ONLY_HIGH")]).
            *   **Save**: Save resulting binary to `media/cards/{uuid4()}.png`.
            *   **Return**: Relative path to the saved image.
            *   **Error Handling**: Handle rate limits with exponential backoff.
            *   **Safety Settings**: Allows mild vulgar/meme content while blocking extreme NSFW content.
                *   All safety categories (`HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`, `HARM_CATEGORY_DANGEROUS_CONTENT`) are set to `BLOCK_ONLY_HIGH`.
    *   **Note**: The `aspect_ratio` parameter is not supported in the current Gemini SDK version and the model will generate an appropriate aspect ratio automatically.
*   Create `services/nano_banana.py`.
    *   Inherits from `ArtForgeService` to maintain style consistency.
    *   Provides `generate_from_prompt()` method for manual flows.
    *   Uses the same underlying generation logic as `ArtForgeService`.
*   Create `services/battle_engine.py` with battle calculation logic (stats, biome bonuses, RNG, MEME crits)
*   Create `services/chat_import.py` to import chat history from Telegram JSON exports.

## UTILS

*   Create `utils/images.py` helper for image saving
    *   Function `save_generated_image(image_bytes: bytes, directory: str = "media/cards") -> str`:
        *   Decodes bytes if needed.
        *   Generates a UUID filename.
        *   Saves to disk.
        *   Returns the relative filepath.
*   Create `utils/keyboards.py` for keyboard creation.
    *   `get_main_menu_keyboard()` - Reply keyboard with main menu options
    *   `get_main_menu_inline_keyboard()` - Inline keyboard for main menu options
    *   `get_inventory_keyboard()` - Inline keyboard for inventory with pagination
    *   `get_card_detail_keyboard()` - Inline keyboard for viewing individual cards
    *   `get_profile_keyboard()` - Inline keyboard for profile/stats
    *   `get_help_keyboard()` - Inline keyboard for help/guide
    *   Callback data classes for all interactions (pagination, card viewing, navigation)
    *   `ScrapCardCallback` - Callback data for scrapping (deleting) cards.
        *   `card_id` (str): UUID as string
        *   `return_page` (int): Page to return to in inventory
        *   `confirm` (bool): Whether this is a confirmation step
*   Create `utils/text.py` with `escape_markdown()` to escape special characters in user-provided content.
*   Create `utils/emojis.py` with:
    *   `get_biome_emoji(biome: BiomeType)`
    *   `get_rarity_emoji(rarity: Rarity)`
*   Create `utils/commands.py` with command definitions and helper functions
    *   `get_player_commands()` - Returns a list of player commands with Ukrainian descriptions
    *   `get_admin_commands()` - Returns a list of admin commands with Ukrainian descriptions
    *   `get_all_commands()` - Returns a list of all commands (player + admin) with Ukrainian descriptions
    *   `is_admin(user_id: int)` - Checks if a user ID is in the list of admin user IDs.

## USER INTERFACE

*   Implement a full keyboard system with:
    *   Reply Keyboards (persistent buttons): Main menu navigation
    *   Inline Keyboards: Inventory browsing, card details, and actions
*   Reply Keyboards (persistent buttons): Main menu navigation
*   Inline Keyboards: Inventory browsing, card details, and actions
*   Menu Structure:
    *   Main Menu (Reply Keyboard)
        *   üìä –ü—Ä–æ—Ñ—ñ–ª—å (Profile)
        *   üé¥ –ö–æ–ª–µ–∫—Ü—ñ—è (Inventory)
        *   ‚ùì –î–æ–ø–æ–º–æ–≥–∞ (Help)
    *   Profile View (Inline Keyboard)
        *   üîô –ù–∞–∑–∞–¥ (Back to Main Menu)
    *   Inventory View (Inline Keyboard)
        *   Navigation: ‚¨ÖÔ∏è –ü–æ–ø–µ—Ä–µ–¥–Ω—è / –ù–∞—Å—Ç—É–ø–Ω–∞ ‚û°Ô∏è
        *   Filter/Sort options (if applicable)
        *   üîô –ù–∞–∑–∞–¥ (Back to Main Menu)
    *   Card Detail View (Inline Keyboard)
        *   Navigation: ‚¨ÖÔ∏è –ü–æ–ø–µ—Ä–µ–¥–Ω—è / –ù–∞—Å—Ç—É–ø–Ω–∞ ‚û°Ô∏è
        *   üîô –î–æ –ö–æ–ª–µ–∫—Ü—ñ—ó (Back to Inventory)
        *   üî© –†–æ–∑–ø–∏–ª–∏—Ç–∏ (–û—Ç—Ä–∏–º–∞—Ç–∏ –†–µ